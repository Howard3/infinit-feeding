// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: bulk_upload.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const countBulkUploads = `-- name: CountBulkUploads :one
SELECT
	COUNT(*)
FROM
	bulk_upload_projections
`

func (q *Queries) CountBulkUploads(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countBulkUploads)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getBulkUploadByID = `-- name: GetBulkUploadByID :one
SELECT
	id,
	status,
	target_domain,
	file_id,
	initiated_at,
	completed_at,
	invalidation_started_at,
	invalidation_completed_at,
	total_records,
	processed_records,
	failed_records,
	upload_metadata,
	version,
	updated_at
FROM
	bulk_upload_projections
WHERE
	id = ?
LIMIT
	1
`

func (q *Queries) GetBulkUploadByID(ctx context.Context, id string) (BulkUploadProjection, error) {
	row := q.db.QueryRowContext(ctx, getBulkUploadByID, id)
	var i BulkUploadProjection
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.TargetDomain,
		&i.FileID,
		&i.InitiatedAt,
		&i.CompletedAt,
		&i.InvalidationStartedAt,
		&i.InvalidationCompletedAt,
		&i.TotalRecords,
		&i.ProcessedRecords,
		&i.FailedRecords,
		&i.UploadMetadata,
		&i.Version,
		&i.UpdatedAt,
	)
	return i, err
}

const listBulkUploads = `-- name: ListBulkUploads :many
SELECT
	id,
	status,
	target_domain,
	file_id,
	initiated_at,
	completed_at,
	invalidation_started_at,
	invalidation_completed_at,
	total_records,
	processed_records,
	failed_records,
	upload_metadata,
	version,
	updated_at
FROM
	bulk_upload_projections
ORDER BY
	initiated_at DESC
LIMIT
	?
OFFSET
	?
`

type ListBulkUploadsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListBulkUploads(ctx context.Context, arg ListBulkUploadsParams) ([]BulkUploadProjection, error) {
	rows, err := q.db.QueryContext(ctx, listBulkUploads, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BulkUploadProjection{}
	for rows.Next() {
		var i BulkUploadProjection
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.TargetDomain,
			&i.FileID,
			&i.InitiatedAt,
			&i.CompletedAt,
			&i.InvalidationStartedAt,
			&i.InvalidationCompletedAt,
			&i.TotalRecords,
			&i.ProcessedRecords,
			&i.FailedRecords,
			&i.UploadMetadata,
			&i.Version,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertBulkUploadProjection = `-- name: UpsertBulkUploadProjection :exec
INSERT
OR REPLACE INTO bulk_upload_projections (
	id,
	status,
	target_domain,
	file_id,
	initiated_at,
	completed_at,
	invalidation_started_at,
	invalidation_completed_at,
	total_records,
	processed_records,
	failed_records,
	upload_metadata,
	version,
	updated_at
)
VALUES
	(
		?,
		?,
		?,
		?,
		?,
		?,
		?,
		?,
		?,
		?,
		?,
		?,
		?,
		datetime ('now')
	)
`

type UpsertBulkUploadProjectionParams struct {
	ID                      string       `json:"id"`
	Status                  string       `json:"status"`
	TargetDomain            string       `json:"targetDomain"`
	FileID                  string       `json:"fileId"`
	InitiatedAt             time.Time    `json:"initiatedAt"`
	CompletedAt             sql.NullTime `json:"completedAt"`
	InvalidationStartedAt   sql.NullTime `json:"invalidationStartedAt"`
	InvalidationCompletedAt sql.NullTime `json:"invalidationCompletedAt"`
	TotalRecords            int64        `json:"totalRecords"`
	ProcessedRecords        int64        `json:"processedRecords"`
	FailedRecords           int64        `json:"failedRecords"`
	UploadMetadata          string       `json:"uploadMetadata"`
	Version                 int64        `json:"version"`
}

func (q *Queries) UpsertBulkUploadProjection(ctx context.Context, arg UpsertBulkUploadProjectionParams) error {
	_, err := q.db.ExecContext(ctx, upsertBulkUploadProjection,
		arg.ID,
		arg.Status,
		arg.TargetDomain,
		arg.FileID,
		arg.InitiatedAt,
		arg.CompletedAt,
		arg.InvalidationStartedAt,
		arg.InvalidationCompletedAt,
		arg.TotalRecords,
		arg.ProcessedRecords,
		arg.FailedRecords,
		arg.UploadMetadata,
		arg.Version,
	)
	return err
}
